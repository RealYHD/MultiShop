@using ShopFramework
@using SimpleLogger
@using System.Reflection
@using Microsoft.Extensions.Configuration
@inject HttpClient Http
@inject IConfiguration Configuration
@inherits LayoutComponentBase
@implements IDisposable

<div class="page">
    <NavMenu />
    <div class="main">
        <div class="content px-4">
            @if (modulesLoaded)
            {
                <CascadingValue Value="shops" Name="Shops">
                    @Body
                </CascadingValue>
            }
        </div>
    </div>
</div>

@code {
    private bool modulesLoaded = false;

    private Dictionary<string, IShop> shops = new Dictionary<string, IShop>();
    private Dictionary<string, Assembly> unusedDependencies = new Dictionary<string, Assembly>();
        
    protected override async Task OnInitializedAsync()
    {
        await DownloadShopModules();
        await base.OnInitializedAsync();
    }
    private async Task DownloadShopModules() {
        Logger.Log($"Fetching shop modules.", LogLevel.Debug);
        string[] shopNames = await Http.GetFromJsonAsync<string[]>(Configuration["ModulesList"]);
        Task<byte[]>[] assemblyDownloadTasks = new Task<byte[]>[shopNames.Length];

        for (int i = 0; i < shopNames.Length; i++)
        {
            string shopPath = Configuration["ModulesDir"] + shopNames[i] + ".dll";
            assemblyDownloadTasks[i] = Http.GetByteArrayAsync(shopPath);
            Logger.Log($"Downloading \"{shopPath}\".", LogLevel.Debug);
        }

        AppDomain.CurrentDomain.AssemblyResolve += OnAssemblyDependencyRequest;

        foreach (Task<byte[]> task in assemblyDownloadTasks)
        {
            Assembly assembly = AppDomain.CurrentDomain.Load(await task);
            bool assigned = false;
            foreach (Type type in assembly.GetTypes())
            {
                if (typeof(IShop).IsAssignableFrom(type)) {
                    IShop shop = Activator.CreateInstance(type) as IShop;
                    if (shop != null) {
                        shop.Initialize();
                        shops.Add(shop.ShopName, shop);
                        Logger.Log($"Registered and started lifetime of module for \"{shop.ShopName}\".", LogLevel.Debug);
                    } 
                    assigned = true;
                }
            }
            if (!assigned) {
                unusedDependencies.Add(assembly.FullName, assembly);
                Logger.Log($"Assembly \"{assembly.FullName}\" did not contain a shop module. Storing it as potential extension.", LogLevel.Debug);
            }
        }
        foreach (string assembly in unusedDependencies.Keys)
        {
            Logger.Log($"{assembly} was unused.", LogLevel.Warning);
        }
        unusedDependencies.Clear();
        modulesLoaded = true;
    }

    
    private Assembly OnAssemblyDependencyRequest(object sender, ResolveEventArgs args) {
        Logger.Log($"Assembly {args.RequestingAssembly} is requesting dependency assembly {args.Name}.", LogLevel.Debug);
        if (unusedDependencies.ContainsKey(args.Name))
        {
            Logger.Log("Dependency found.", LogLevel.Debug);
            Assembly dependency = unusedDependencies[args.Name];
            unusedDependencies.Remove(args.Name);
            return dependency;
        }
        Logger.Log($"No dependency under name {args.Name}", LogLevel.Debug);
        return null;
    }


    public void Dispose() {
        foreach (string name in shops.Keys)
        {
            shops[name].Dispose();
            Logger.Log($"Ending lifetime of shop module for \"{name}\".");
        }
    }
}